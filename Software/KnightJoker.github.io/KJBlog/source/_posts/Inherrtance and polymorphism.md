title: 继承和多态

categories:
- iOS
tags:
- 面向对象

---

继承是面向对象的三大特征之一。Objective - C的继承具有单继承的特点，每个子类只有一个直接的父类。
<br>
## 继承
<br>
Objective - C 的继承通过父类的语法来实现，实现继承的类被称为子类，被继承的类被称为父类，有的也称其为基类、超类。

Objective - C 里子类继承父类的语法格式如下：

```
	@interface SubClass ：SuperClass
	{
		//成员变量定义
	}
	//方法定义部分
	@end	
```
当子类扩展父类时，子类可以继承得到父类的如下东西：

- 全部成员变量

- 全部方法（包括初始化方法）

并且在 Objective - C 中摒弃了C++中难以理解的多继承特征，即每个类最多只有一个直接父类。从子类角度来看，子类**扩展（extends）**了父类；但从父类的角度来看，父类**派生（derive）**出了子类。

#### 重写父类的方法

<br>
当子类要重写父类方法时候，子类接口部分并不需要重新声明要重写的方法，只要在类的实现部分直接重写该方法即可，但注意子类的接口部分不允许定义与父类接口部分重名的成员变量。

这种子类包含与父类同名方法的现象被称作**方法重写**，也被称作**方法覆盖（Override）**。在这里必须要注意方法签名关键字要完全相同，也就是方法名和方法签名中的形参标签都需要完全相同，否则就不能算方法重写。

如果需要在子类方法中调用父类被覆盖的方法，可以使用`super`关键字来调用父类被覆盖的方法。（该关键字用于限定该对象调用它从父类继承得到的属性或者方法）

<br>
## 多态
<br>
Objective - C指针类型的变量有两个：一个是编译时的类型，一个是运行时的类型，编译时的类型由声明该变量时使用的类型决定，运行时的类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态（Polymorphism）。

因为子类其实就是一个特殊的父类，所以，在 Objective - C 中允许把一个子类对象直接赋给一个父类指针变量，无须任何类型转换，或者被称为向上转型（upcasting），向上转型由系统自动完成。

这里举例说明：
父类KJBase：

```

	@interface KJBase ：NSObject
	
	- (void) test1;
	
	@end
	
```
子类KJSubclass：

```

	@interface KJSubclass : KJBase
	
	- (void) test2;
	
	@end
		
```

当把一个子类对象直接赋给父类指针变量，比如`KJBase* ploymophicBc = [[KJSubclass alloc] init];`这里的KJSubclass为子类，KJBase为父类。这个ploymophicBc变量的编译时类型是KJBase，而运行时类型是KJSubclass，当运行时调用该指针变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就有可能出现：相同类型的变量调用同一个方法时呈现出多种不同的行为特征，这便就是多态了。

指针变量在编译阶段只能调用其编译类型所具有的方法，但运行时则执行它所运行类型所具有的方法，指针变量只能调用声明该变量时所用类中包含的方法。

比如在这里如果有` ploymophicB.test2();`这行代码会在编译时引发错误。虽然ploymophicBc变量实际指向的对象却是包含test2（）方法，但是因为它的编译类型为KJBase，因此编译时候无法调用test2()方法。

如果这里需要让这个指针变量调用它运行时类型的方法，则必须强制类型转换成运行时类型，强制类型转换需要借助**类型转换运算符**，其用法为：（type *）variable，这里便将variable变量转换成一个type类型的变量。（为了保证代码的鲁棒性，在进行强制类转换之前，首先判断前一个对象是否是该类的实例，是否可以成功地转换，从而保证代码更加健壮。）

