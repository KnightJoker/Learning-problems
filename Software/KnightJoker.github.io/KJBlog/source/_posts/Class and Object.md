
title: 类和对象

categories:
- iOS
tags:
- 面向对象

---
Objective-C 作为面向对象的程序设计语言，也支持面向对象的三大特征：封装、继承和多态。

然而在其程序设计过程中有两个比较重要的概念：类（class）和对象（object，也称为实例）

<br>

## 定义类

在Objective-C中定义一个类，主要分为两个步骤：

- 接口部分：定义该类包含的成员变量和方法

- 实现部分：为该类的方法提供实现


**定义接口部分的语法实现：**

```

	 @interface MyClass : NSObject
	 
	 {
	 	int _count;
	 	id _data;
	 	NSString* _name;
	 }
	 
	 - (id)initMyName:(NSString *)aName;
	 + (MyClass *)creatMyClassWithName:(NSString *)aName;
	 
	 @end
```

在上面的语法格式中，@interface 用于声明类的接口部分，@end 表明定义结束。

其中紧跟在该类用的一对花括号用于声明该类的成员变量，花括号后面的部分则是声明该类的方法。

类的接口部分可以在类名后使用“：父类”来表示继承了某个父类

*成员变量：*用于描述该类的对象状态数据。

*方法：*用于表述该类的行为。


<br>
一般来说定义类的接口声明都会放在头文件中，也就是源代码中 `.h`的文件。

注意规范，从Xcode 4开始，建议成员变量名以下划线*（_）*开头

有关于*方法声明*的语法请注意如下几条：

```

	1.方法类型标识：该标识要么是+，要么是-，其中+代表该方法是类方法，直接使用类名即可调用；-代表该方法是实例方法，必须用对象才能调用。
	
	2.方法返回值类型
	
	3.方法签名关键字：Objective-C的方法签名关键字由方法名、形参标签和冒号组成。（方法名命名规范与成员变量规范基本相同，不过不需要以下划线为开头，建议以英文动词开头；注意保留形参标签）
	
```


**定义类实现部分的语法：**

```

	@implementation MyClass
	{	
		int _count;
	 	id _data;
	 	NSString* _name;
	}
	
	- (id)initMyName:(NSString *)aName
	{
	 	//方法体
	}
	
	+ (MyClass *)creatMyClassWithName:(NSString *)aName
	{
	 	//方法体
	}

```

类实现部分的类名必须与类接口部分的类名相同，表示这是同一个类的接口部分和实现部分。

类实现部分也可以声明自己的成员变量，但是这些成员变量只能在当前的类内访问。因此，在这里声明的成员变量相当于定义隐藏的成员变量。

类实现部分必须为类声明部分的每个方法提供方法定义。（注意这个地方，方法体里面的可执行语句之间有着很严格的执行顺序，排在前面的先执行，后面的排队！！！！！！！）

实现部分的源文件通常为`.m`文件


<br>

### 对象的产生和使用

<br>

在定义类之后，可以从如下三当面来使用类。

- 定义变量

- 创建对象

- 调用类方法

**定义变量的语法：**

```
	类名* 变量名；
```

**创建对象的语法：**

```
	[[类名 alloc] 初始化方法];
```


由于所有的对象都继承了NSObject类，所以所有的类都有一个默认的初始化方法：init


**调用类方法:**

```
	[调用者 方法名：参数 形参标签：参数值];
```

(虽然在oc中允许调用方法传入参数时，省略形参标签，但这样做会降低程序的可读性，所以不建议省略形参标签)


#### 对象和指针

举个例子来说：`KJPerson* person = [[KJPerson alloc] init];`

从本质上来说，类也是一个指针类型的变量，因此`KJPerson*`类型只是存放了一个地址值，他被保存在该`main()`函数的动态存储区，而真正的`KJPerson`对象则是放在堆（heap）内存中。

`main()`方法的动态存储区保存的指针变量并未真正存储对象里的成员变量数据，而指针变量仅仅只是指向该对象。
一个对象被创建成功之后，这个对象将保存在堆内存中，然后Objective-C不允许直接访问堆内存中的对象，只能通过该对象的指针变量来访问该对象。

如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，因此程序员应该释放该对象所占用的内存，否则将会造成内存泄漏。

#### 单例

在程序并不需要创建多次某一类的对象，且需要保证该类只有一个实例的时候，则可以使用单例。

如果一个类始终只能创建一个实例，则这个类被称为单例类。（单例类可以通过static全局变量来实现）

```
	+ (id) instance
	{
		if(!instance)
		{
			instance = [[super alloc] init];
		}
		return instance;
	}
```

