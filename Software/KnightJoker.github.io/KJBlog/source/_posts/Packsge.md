title: 封装和隐藏

date: 2016/05/07 20:46:25

categories:
- iOS
tags:
- 面向对象

---
**封装**（Encapsulation）是面向对象的三大特征之一（另外两个是继承和多态），它指的是讲对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。

因此一个类或对象实现良好的封装，有以下几个目的：

1. 隐藏类实现的细节

2. 让使用者只能通过实现预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问。

3. 可进行数据检查，从而有利于保证对象信息的完整性。

4. 便于修改，提高代码的可维护性。

然而为了实现良好的封装，则需要从以下两个方面进行考虑：

1. 将对象的成员变量和实现细节都隐藏起来，不允许外部直接访问。

2. 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。

**使用访问控制符**

为了封装的良好目的性，Objective-C提供访问控制符来实现：

- @private

- @packsge

- @protected

- @public

然而其访问控制级别由小到大（由上到下）如下图所示：

![](img/访问控制级别.png)

关于四个访问控制级别的详细介绍如下：

- `@private`(当前类访问权限)：如果类的成员变量使用@private访问控制符来限制，则这个成员只能在当前类的内部被访问。这个访问控制符用于彻底隐藏成员变量。在类的实现部分定义的成员变量相当于默认使用这种访问权限。

- `@package`(与映像访问权限相同)：如果类的成员变量使用其来访问控制限制，则这个成员可以在当前类以及当前类实现的同一个映像的任意地方访问。很显然这个访问控制符用于部分隐藏成员变量。

- `@protected`(子类访问权限):这个成员可以在当前类或者当前类的子类的任意地方进行访问。一般这个访问控制符用于部分暴露成员变量。在类的接口部分定义的成员变量默认使用这种访问权限。

- `@public`(公共访问权限):这是一个最宽松的访问控制级别，这个成员变量可以在任意地方访问。

在上面四个访问控制权限中，@private 是最小的访问权限，@packeage 、@protected 既有重叠的部分———他们包括了@private 的范围，其中，@package 限制的成员变量可以被相同镜像的其他程序访问；@protected 限制的成员可以被当前类的子类访问。

一个类常常就是一个小的模块，在程序设计时，应该尽量避免一个模块直接操作和访问另一个模块的数据，模块设计追求高内聚（尽可能把模块的内部数据、功能实现细节隐藏在模块内部独立完成，不允许外部直接干预）、低耦合（仅暴露少量的方法给外部使用）。

**合成存取方法**

从 Objective - C 2.0版本开始它就自动合成了所谓的getter方法和setter方法：

在类的接口部分使用`@property`指令定义属性。使用 @property 定义属性时无须放在类接口部分的花括号内，而是直接放在`@interface`、`@end`之间定义。@property指示符放在属性定义的最前面。

比如：`@property (nonatomic,copy,assign) NSString* name;`

正如前面代码中看到的，当使用 @property 定义property时，还可以在@property和类型之间用括号添加一些额外的指示符，其使用的特殊指示符如下：

- assign：该指示符对属性只是进行简单的赋值，不改变对所赋的值得引用计数。一般这个指示符主要适用于NSIterger等基础类型，以及short、float、double、结构体等各种C数据类型。

- atomic（nonatomic）：指定合成的存取方法是否为原子操作。所谓**原子操作**，主要是指是否线程安全。如果使用atomic，那么合成的存、取方法都是线程安全的——当一个线程进入存、取方法的方法体之后，其他的线程便无法进入，这样就可以避免多线程并发破坏对象的数据完整性，atomic是默认值。虽然atomic可以保证对象数据的完整性，但atomic的线程安全会造成性能下降，因此，大多数单线程环境下，我们都可以考虑使用nonatomic来提高存取方法的访问性能。

- copy：当成员变量的类型是可变类型，或者其子类是可变类型时，被赋值的对象有可能在赋值之后被修改，如果程序不需要这种修改影响setter方法设置成员变量的值，此时就可以考虑使用copy指示符。

在对属性进行访问的时候，可以使用**点语法**访问属性和对属性赋值。


